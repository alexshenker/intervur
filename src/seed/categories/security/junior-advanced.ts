import { Category, Level, ValidTag } from "../../../db/constants";
import type { QuestionForCategoryAndLevel } from "../../../lib/types";

export const juniorAdvanced: QuestionForCategoryAndLevel<
    typeof Category.enum.security,
    typeof Level.enum["junior-advanced"]
>[] = [
    // Authentication Basics
    {
        text: "What is the difference between authentication and authorization?",
        level: Level.enum["junior-advanced"],
        category: Category.enum.security,
        tags: [ValidTag.enum.auth, ValidTag.enum.authorization],
        answers: ["Authentication and authorization are often confused but they're fundamentally different. Authentication is about verifying who you are - like logging in with a username and password to prove your identity. Authorization happens after that and determines what you're allowed to do. For example, once you're authenticated as a user, authorization checks whether you have permission to access certain resources or perform specific actions. So authentication answers 'who are you?' while authorization answers 'what are you allowed to do?'", "Think of it this way - authentication is proving your identity, authorization is checking your permissions. When you log into a system with your credentials, that's authentication - the system now knows who you are. Authorization comes next and controls what actions you can take. A regular user might be able to view their own profile, but only an admin is authorized to delete accounts. In code, you typically authenticate first in middleware, then check authorization before each protected action. They work together but serve distinct purposes in the security flow."],
    },
    {
        text: "What are JWTs and how do they work?",
        level: Level.enum["junior-advanced"],
        category: Category.enum.security,
        tags: [ValidTag.enum.jwt, ValidTag.enum.auth],
        answers: ["JWTs, or JSON Web Tokens, are a compact way to securely transmit information between parties as a JSON object. They're commonly used for authentication. Here's how they work: when a user logs in, the server creates a JWT containing claims about the user, signs it with a secret key, and sends it to the client. The client then includes this token in subsequent requests, typically in the Authorization header. The server can verify the token's signature to ensure it hasn't been tampered with and extract the user information from it without hitting the database. The key benefit is that they're stateless - the server doesn't need to store session data since all the information is contained in the token itself.", "A JWT is essentially a signed JSON payload that lets you verify a user without checking a database on every request. When someone logs in, the server creates a token with user data, signs it cryptographically, and returns it. The client sends this token with each request in the Authorization header as 'Bearer <token>'. The server verifies the signature matches and trusts the data inside. The stateless nature makes JWTs ideal for distributed systems - any server can validate the token independently. Just remember, the payload is encoded but not encrypted, so don't put sensitive data in there."],
    },
    {
        text: "What is the structure of a JWT?",
        level: Level.enum["junior-advanced"],
        category: Category.enum.security,
        tags: [ValidTag.enum.jwt],
        answers: ["A JWT has three parts separated by dots: header, payload, and signature. The header contains metadata like the token type and signing algorithm, usually HS256 or RS256. The payload contains the claims - the actual data you want to transmit, like user ID, email, or permissions. Then there's the signature, which is created by encoding the header and payload together with a secret key. All three parts are Base64URL encoded, so a JWT looks like 'xxxxx.yyyyy.zzzzz'. The important thing to remember is that while the data is encoded, it's not encrypted, so you shouldn't put sensitive information in the payload. The signature just ensures the token hasn't been modified.", "A JWT is three Base64-encoded parts joined by dots. The header specifies the algorithm used for signing, like HS256 for symmetric or RS256 for asymmetric encryption. The payload holds your claims - standard ones like 'exp' for expiration or 'sub' for subject, plus custom claims like user roles. The signature ties it together - it's a hash of the header and payload using your secret key. Anyone can decode and read the header and payload, but only the server with the secret can verify the signature is valid. That's why you never store passwords or secrets in the payload."],
    },
    {
        text: "What is the difference between sessions and JWTs?",
        level: Level.enum["junior-advanced"],
        category: Category.enum.security,
        tags: [ValidTag.enum.jwt, ValidTag.enum["session-management"], ValidTag.enum.auth],
        answers: ["The main difference is where the authentication state is stored. With sessions, the server stores the user's session data in memory, a database, or Redis, and gives the client a session ID cookie. On each request, the server looks up that session ID to get the user's information. With JWTs, all the user information is stored in the token itself on the client side, and the server just verifies the signature. This makes JWTs stateless, which is great for scaling horizontally since any server can validate the token. However, sessions give you more control - you can immediately invalidate a session, while with JWTs, once issued, they're valid until they expire. Sessions also keep less data on the client and can handle larger amounts of session data.", "Sessions are stateful, JWTs are stateless - that's the core difference. With sessions, the server keeps track of who's logged in, usually in Redis or a database, and the client just holds a session ID in a cookie. Each request requires a server lookup. JWTs flip this - all the user info lives in the token itself, so any server can validate it without shared state. Sessions win when you need instant logout or revocation. JWTs win for microservices and horizontal scaling. Most production systems actually use both - a JWT for stateless API calls and session-like refresh token tracking for security."],
    },

    // Security Basics
    {
        text: "What is CSRF and how do you prevent it?",
        level: Level.enum["junior-advanced"],
        category: Category.enum.security,
        tags: [ValidTag.enum.csrf, ValidTag.enum.security],
        answers: ["CSRF, or Cross-Site Request Forgery, is when an attacker tricks a user's browser into making unwanted requests to a site where they're authenticated. For example, you're logged into your bank, and you visit a malicious site that contains a form that submits a transfer request to your bank using your cookies. The main prevention is CSRF tokens - you generate a random token, store it in the session, and include it in forms or as a header. When the form is submitted, you verify the token matches. This works because the attacker can't access the token due to same-origin policy. Other defenses include SameSite cookies, which prevent the browser from sending cookies on cross-site requests, and checking the Origin or Referer headers. For APIs, if you're using custom headers for authentication instead of cookies, you're already protected.", "CSRF exploits the browser's automatic cookie sending. If you're logged into a site, your browser sends cookies with every request to that domain - even from a malicious page. An attacker can craft a hidden form that submits a money transfer using your authenticated session. The fix is CSRF tokens - unique per-session tokens that the attacker can't guess or read due to same-origin policy. Modern frameworks generate these automatically. SameSite cookies are another layer - setting SameSite=Strict or Lax prevents cookies from being sent on cross-origin requests. If you're building APIs with Bearer tokens instead of cookies, CSRF isn't a concern since tokens aren't sent automatically."],
    },
    {
        text: "What is XSS and what are the different types?",
        level: Level.enum["junior-advanced"],
        category: Category.enum.security,
        tags: [ValidTag.enum.xss, ValidTag.enum.security],
        answers: ["XSS, or Cross-Site Scripting, is when an attacker injects malicious JavaScript into your application that runs in other users' browsers. There are three main types. Stored XSS is the most dangerous - the malicious script is saved in your database, like in a comment or profile, and executes whenever someone views that content. Reflected XSS happens when user input from the URL or form is immediately reflected back in the response without sanitization. DOM-based XSS occurs entirely in the browser when client-side JavaScript processes user input unsafely. To prevent XSS, you need to escape output based on context - HTML escaping for content, JavaScript escaping for scripts, URL encoding for URLs. Use Content Security Policy headers, avoid innerHTML, and use frameworks like React that escape by default. Never trust user input.", "XSS lets attackers run their JavaScript in your users' browsers, which can steal cookies, capture keystrokes, or hijack sessions. Stored XSS persists in your database - think a malicious script in a comment field that hits every viewer. Reflected XSS bounces malicious input from a URL parameter straight into the page. DOM-based XSS happens purely client-side when JavaScript unsafely handles user input. Prevention starts with output encoding - escape HTML entities when rendering user content. Modern frameworks like React do this by default, but watch out for dangerouslySetInnerHTML. Add a Content Security Policy header to block inline scripts entirely. Always treat user input as hostile."],
    },
    {
        text: "What is SQL injection and how do you prevent it?",
        level: Level.enum["junior-advanced"],
        category: Category.enum.security,
        tags: [ValidTag.enum["sql-injection"], ValidTag.enum.security],
        answers: ["SQL injection is when an attacker manipulates your SQL queries by injecting malicious input. For example, if you build a query like 'SELECT * FROM users WHERE username = ' + userInput, an attacker could input something like 'admin' OR '1'='1' to bypass authentication or use UNION attacks to access other tables. The primary defense is parameterized queries or prepared statements, which separate the SQL structure from the data. Instead of concatenating strings, you use placeholders and let the database driver handle escaping. With an ORM like Prisma or TypeORM, you're generally protected if you use their query builders. Also validate input - ensure usernames only contain expected characters. And apply the principle of least privilege - database users should only have permissions they need.", "SQL injection happens when user input becomes part of your SQL query and changes its logic. Classic example: a login form where entering ' OR '1'='1 as the password bypasses authentication because it makes the WHERE clause always true. The solution is simple - never concatenate user input into queries. Use parameterized queries where the database treats input strictly as data, not code. ORMs handle this for you, but be careful with raw query methods. Defense in depth means also using a database user with minimal permissions, so even if injection happens, the damage is limited. Input validation helps too, but parameterization is the real fix."],
    },
    {
        text: "What is CORS and why does it exist?",
        level: Level.enum["junior-advanced"],
        category: Category.enum.security,
        tags: [ValidTag.enum.cors, ValidTag.enum.security],
        answers: ["CORS, or Cross-Origin Resource Sharing, is a security mechanism that controls which websites can make requests to your API from the browser. It exists because of the same-origin policy, which by default prevents JavaScript from making requests to different domains. Without this, a malicious site could make requests to your bank's API using your cookies. CORS lets you selectively relax this restriction. When a browser makes a cross-origin request, it first sends a preflight OPTIONS request asking if the request is allowed. Your server responds with CORS headers like Access-Control-Allow-Origin specifying which origins are permitted. If the origin is allowed, the browser proceeds with the actual request. It's important to understand that CORS is a browser security feature - it doesn't prevent tools like curl from making requests.", "CORS is the browser's way of asking your server 'is this website allowed to call you?' By default, browsers block cross-origin requests to protect users from malicious sites making API calls with their cookies. Your server uses CORS headers to whitelist trusted origins. For non-simple requests, the browser sends a preflight OPTIONS request first, and only proceeds if the server approves. Key thing to understand: CORS is enforced by browsers, not servers. Your API is still accessible from Postman or curl - CORS only protects browser users. Configure it by setting Access-Control-Allow-Origin to specific domains, never use wildcard with credentials."],
    },
    {
        text: "What is HTTPS and how does TLS work?",
        level: Level.enum["junior-advanced"],
        category: Category.enum.security,
        tags: [ValidTag.enum.security],
        answers: ["HTTPS is HTTP over TLS, which encrypts the communication between client and server so no one can eavesdrop or tamper with it. Here's how the TLS handshake works: the client connects and the server sends its certificate, which contains its public key. The client verifies this certificate against trusted certificate authorities. Then the client generates a session key, encrypts it with the server's public key, and sends it back. Now both parties have the same session key and use it for symmetric encryption going forward - symmetric is much faster than asymmetric. This provides confidentiality through encryption, integrity through message authentication codes, and authenticity through certificate validation. Modern TLS 1.3 is even faster with fewer round trips. The important thing is HTTPS should be everywhere now - it's free with Let's Encrypt and essential for security.", "HTTPS wraps HTTP in TLS encryption so attackers can't read or modify data in transit. The TLS handshake establishes trust and creates an encrypted channel. The server presents a certificate proving its identity, signed by a trusted certificate authority. They then negotiate a shared symmetric key for the actual encryption - asymmetric crypto is only used for this initial key exchange because it's slower. After the handshake, all traffic is encrypted and authenticated. TLS 1.3 simplified this to just one round trip. There's really no reason not to use HTTPS everywhere now - Let's Encrypt provides free certificates, and browsers actively warn users about HTTP sites."],
    },
    {
        text: "How do you securely store passwords?",
        level: Level.enum["junior-advanced"],
        category: Category.enum.security,
        tags: [ValidTag.enum["password-hashing"], ValidTag.enum.bcrypt, ValidTag.enum.security],
        answers: ["You never store passwords in plain text - always hash them using a strong, slow hashing algorithm designed for passwords. The current best practices are bcrypt, scrypt, or Argon2. These algorithms are intentionally slow and include a salt automatically to prevent rainbow table attacks. When a user registers, you hash their password and store only the hash. On login, you hash the submitted password and compare it to the stored hash. The key is these algorithms have a work factor you can tune - as computers get faster, you increase the work factor to keep brute force attacks expensive. Never use fast algorithms like MD5 or SHA-1 for passwords. Don't try to implement your own - use well-tested libraries. And enforce strong password requirements, though passphrase-based approaches are often better than complex character requirements.", "Never store plain text passwords - hash them with bcrypt, scrypt, or Argon2. These are deliberately slow algorithms, which is exactly what you want. Fast hashing like SHA-256 lets attackers try billions of guesses per second; bcrypt might allow only thousands. Each hash includes a unique salt, so even identical passwords produce different hashes, defeating rainbow tables. Store only the hash. When users log in, hash their input and compare. The cost factor is adjustable - start around 10-12 for bcrypt and increase over time as hardware improves. Use established libraries like bcryptjs, never roll your own crypto."],
    },
    {
        text: "What is the difference between encryption and hashing?",
        level: Level.enum["junior-advanced"],
        category: Category.enum.security,
        tags: [ValidTag.enum.security],
        answers: ["The fundamental difference is that encryption is reversible while hashing is one-way. With encryption, you transform data using a key so it's unreadable, but you can decrypt it back to the original using the key. You use encryption when you need to retrieve the original data later, like encrypting credit card numbers or messages. Hashing, on the other hand, is a one-way function that produces a fixed-size output from any input. You can't reverse a hash to get the original data. You use hashing when you only need to verify that data hasn't changed, like with passwords - you don't need to know the original password, just verify that what they entered hashes to the same value. Hashing is also used for data integrity and creating unique identifiers.", "Encryption is two-way, hashing is one-way - that's the key distinction. Encrypt data when you need to read it later, like user messages or stored credentials for external services. You have a key to decrypt it back. Hashing produces a fixed-length fingerprint that can't be reversed. Use it for passwords, where you only need to verify a match, not retrieve the original. Also use hashing for integrity checks and deduplication. Different purposes: encryption protects data confidentiality while allowing access with the right key; hashing verifies data without revealing the original content."],
    },
    {
        text: "What is input validation and sanitization?",
        level: Level.enum["junior-advanced"],
        category: Category.enum.security,
        tags: [ValidTag.enum.validation, ValidTag.enum.security],
        answers: ["Input validation and sanitization are both about handling untrusted data safely, but they're different approaches. Validation is about rejecting bad input - you check if the input matches expected criteria and reject it if it doesn't. For example, validating that an email has the right format, or that an age is a number between 1 and 120. Sanitization is about cleaning input to make it safe - you remove or escape dangerous characters. For example, stripping HTML tags from user input or escaping SQL special characters. The best practice is to validate first - use strict validation and reject anything that doesn't match your expected format. Then sanitize what you accept based on how you're using it. Use libraries like Joi or Zod for validation, and context-specific sanitization - HTML escaping for display, SQL parameterization for queries. Never trust user input.", "Validation rejects bad input; sanitization cleans it. Validate by checking if data matches expected patterns - is this a valid email format, is this number in range, does this string only contain allowed characters? Reject anything that fails. Sanitization transforms potentially dangerous input into something safe - escaping HTML entities, removing script tags, encoding special characters. Best practice is validate first, then sanitize for your specific output context. Use schema validation libraries like Zod to define exactly what you expect. The golden rule: never trust user input, validate at system boundaries, and sanitize based on where the data goes."],
    },
];
