import { Category, Level, ValidTag } from "../../../db/constants";
import type { QuestionForCategoryAndLevel } from "../../../lib/types";

export const juniorAdvanced: QuestionForCategoryAndLevel<
    typeof Category.enum.backend,
    typeof Level.enum["junior-advanced"]
>[] = [
    // Express Basics
    {
        text: "What is Express and how does middleware work?",
        level: Level.enum["junior-advanced"],
        category: Category.enum.backend,
        tags: [ValidTag.enum.express, ValidTag.enum.middleware, ValidTag.enum.nodejs],
        answers: [
            "Express is a minimal and flexible Node.js web application framework that provides a robust set of features for building web and mobile applications. It's essentially a layer built on top of Node's HTTP module that makes it easier to handle routing, requests, and responses. Now, middleware is really the heart of Express. It's basically functions that have access to the request object, the response object, and the next middleware function in the request-response cycle. When a request comes in, it flows through a chain of middleware functions - each one can modify the request or response, execute code, or end the request-response cycle. For example, you might have middleware that parses JSON, logs requests, checks authentication, or handles errors. Each middleware either calls next() to pass control to the next middleware, or it sends a response to end the cycle. This pattern makes Express really modular and flexible.",
            "Express is essentially a lightweight framework that sits on top of Node's built-in HTTP server and simplifies web development. Think of it as a routing and middleware pipeline. When I build an API with Express, the core concept I work with is middleware. Middleware functions are like layers an incoming request passes through before reaching the final handler. Each layer can inspect or modify the request and response, and decides whether to pass control to the next layer by calling next(). So if I have logging middleware, then auth middleware, then my route handler, the request flows through each in sequence. If the auth middleware detects an invalid token, it can short-circuit the pipeline and send back a 401 right there. This chain-of-responsibility pattern is what makes Express so composable - I can plug in third-party middleware for body parsing, compression, or security headers without writing that code myself."
        ],
    },
    {
        text: "What is the difference between app.use() and app.get()?",
        level: Level.enum["junior-advanced"],
        category: Category.enum.backend,
        tags: [ValidTag.enum.express, ValidTag.enum.middleware],
        answers: [
            "The key difference is that app.use() is for mounting middleware functions and will match any HTTP method, while app.get() is specifically for handling GET requests to a particular route. So app.use() is more general-purpose - you might use it to apply middleware globally to all routes, like body parsing or authentication. For example, app.use(express.json()) applies to all incoming requests. On the other hand, app.get() is route-specific and method-specific. When you write app.get('/users', handler), that handler only runs for GET requests to that exact path. Another difference is that app.use() with a path will match that path and anything under it - so app.use('/api', middleware) matches /api, /api/users, /api/posts, and so on. But app.get('/api', handler) only matches exactly /api. So in practice, use app.use() for middleware you want to apply broadly, and app.get() when you're defining specific route handlers.",
            "The distinction comes down to purpose and scope. app.get() is a route handler that only fires for HTTP GET requests to a specific path. If you write app.get('/users', handler), that handler executes only when someone makes a GET request to exactly /users. app.use() is broader - it registers middleware that runs for all HTTP methods unless you restrict it, and its path matching is more permissive. When you say app.use('/api', someMiddleware), that middleware runs for /api, /api/anything, /api/deeply/nested, and so on. I typically use app.use() at the top of my application for things like JSON parsing, CORS, and logging that should apply everywhere. Then I use app.get(), app.post(), and so on for my actual route handlers where I care about the specific HTTP method. You could think of app.use() as 'apply this to everything matching this prefix' and app.get() as 'handle this exact route for GET requests.'"
        ],
    },
    {
        text: "What is the request-response cycle in Express?",
        level: Level.enum["junior-advanced"],
        category: Category.enum.backend,
        tags: [ValidTag.enum.express],
        answers: [
            "The request-response cycle is the flow that happens from when a client makes a request to when they get a response back. In Express, when a request comes in, it starts at the top of your middleware stack and flows through each middleware function in order. Each middleware can do something with the request or response, and then it either calls next() to pass control to the next middleware, or it sends a response which ends the cycle. So a typical flow might be: the request comes in, goes through body parsing middleware, then maybe authentication middleware, then your route handler which queries the database, and finally sends back a JSON response. Once any middleware or route handler sends a response using methods like res.send() or res.json(), the cycle ends and that response goes back to the client. If none of the middleware sends a response, you'd typically hit a 404 handler at the end. The important thing is that the cycle must end with a response - you can't just leave it hanging.",
            "When a client sends an HTTP request to your Express server, that kicks off what we call the request-response cycle. The request enters the middleware pipeline and flows through each registered middleware in the order they were added. Each middleware gets the request and response objects and can read or modify them. If a middleware calls next(), it passes control to the next one in line. If it calls res.send(), res.json(), or any method that sends data back, that terminates the cycle and the response goes back to the client. A typical flow looks like: request arrives, body-parser middleware parses JSON, auth middleware verifies the token and attaches user info to the request, route handler fetches data and calls res.json(). The key point is that every request must eventually get a response. If your code never sends one, the client just hangs. That's why we always have a catch-all 404 handler and an error handler at the end of the middleware stack as safety nets."
        ],
    },
    {
        text: "What is the difference between req.params, req.query, and req.body?",
        level: Level.enum["junior-advanced"],
        category: Category.enum.backend,
        tags: [ValidTag.enum.express],
        answers: [
            "These are three different ways to get data from a request. req.params contains route parameters - these are the named segments in your URL path. So if your route is /users/:id and someone requests /users/123, then req.params.id would be '123'. req.query contains the query string parameters - the key-value pairs after the question mark in a URL. So for a request to /search?term=node&limit=10, req.query would be an object with term: 'node' and limit: '10'. These are typically used for optional filters or pagination. req.body contains the data sent in the request body, usually for POST or PUT requests. This is where form data or JSON payloads go, like when creating or updating a resource. You need middleware like express.json() to populate req.body. So to summarize: params for URL path segments, query for URL parameters, and body for data in the request payload.",
            "Each of these pulls data from a different part of the incoming request. req.params holds dynamic segments from the URL path itself. If I define a route like /products/:productId, and someone hits /products/42, then req.params.productId equals '42'. These identify which resource you're accessing. req.query captures everything after the question mark in the URL. For /products?category=electronics&sort=price, req.query gives you { category: 'electronics', sort: 'price' }. Query params are great for filtering, sorting, and pagination since they're optional and don't change the resource identity. req.body is where the actual payload lives for POST, PUT, and PATCH requests. When a client sends JSON data to create or update something, that data ends up in req.body. Important note: req.body is empty by default - you need body-parsing middleware like express.json() to populate it. In practice, I use params to identify resources, query for optional modifiers, and body for data I'm sending to the server."
        ],
    },

    // REST APIs Basics
    {
        text: "What is REST and what are its constraints?",
        level: Level.enum["junior-advanced"],
        category: Category.enum.backend,
        tags: [ValidTag.enum["rest-api"], ValidTag.enum["api-design"]],
        answers: [
            "REST stands for Representational State Transfer, and it's an architectural style for designing networked applications, particularly web services. The idea is that you interact with resources using standard HTTP methods. As for the constraints, there are six main ones. First is client-server separation - the client and server are independent and can evolve separately. Second is statelessness - each request must contain all the information needed to process it, the server doesn't store client context between requests. Third is cacheability - responses should indicate whether they can be cached or not. Fourth is a uniform interface - REST uses standard HTTP methods and URIs to interact with resources in a consistent way. Fifth is a layered system - you can have intermediaries like load balancers or caches between the client and server. And sixth is code-on-demand, which is optional - servers can send executable code to clients. In practice, the most important ones are statelessness and the uniform interface, which make REST APIs predictable and scalable.",
            "REST is an architectural pattern for building APIs that leverages HTTP as its foundation. The core idea is treating everything as a resource that you manipulate using standard HTTP verbs - GET to read, POST to create, PUT to update, DELETE to remove. There are six constraints that define REST. Statelessness means the server doesn't remember anything between requests - every request carries all the context it needs. Client-server separation allows frontend and backend to evolve independently. Cacheability requires that responses declare whether they can be cached. The uniform interface means we interact with resources in a predictable, consistent way using URLs and HTTP methods. A layered system lets us add proxies, load balancers, and caches transparently. Code-on-demand is optional and rarely used - it means servers can send executable code. In my experience, the two that matter most day-to-day are statelessness, which makes scaling straightforward, and the uniform interface, which makes APIs intuitive for developers to consume."
        ],
    },
    {
        text: "What are idempotent operations and why do they matter?",
        level: Level.enum["junior-advanced"],
        category: Category.enum.backend,
        tags: [ValidTag.enum["rest-api"], ValidTag.enum.idempotency],
        answers: [
            "An idempotent operation is one where making the same request multiple times has the same effect as making it once. The result is the same whether you call it once or a hundred times. In HTTP, GET, PUT, and DELETE are idempotent, while POST typically isn't. For example, if you send a PUT request to update a user's email to john@example.com, it doesn't matter if you send that request once or ten times - the email ends up as john@example.com either way. Same with DELETE - deleting a resource once or multiple times results in that resource being gone. But POST isn't idempotent because each request usually creates a new resource. This matters a lot in real-world systems because networks are unreliable. If a client makes a request and doesn't get a response due to a timeout, they don't know if it succeeded or not. With idempotent operations, it's safe to retry - you can send the request again without worrying about unintended side effects. This makes systems more robust and easier to work with, especially in distributed environments.",
            "Idempotency means that performing an operation multiple times produces the same outcome as performing it once. It's a property, not a feature you implement directly. GET is idempotent because reading something repeatedly doesn't change it. PUT is idempotent because setting a value to X gives you X regardless of how many times you do it. DELETE is idempotent because once something is deleted, deleting it again doesn't change anything - it's still gone. POST is typically not idempotent because each call creates a new resource. Why does this matter? Networks fail. Requests time out. Clients retry. If a payment API isn't idempotent and a client retries due to a timeout, you might charge the customer twice. With idempotent operations, retries are safe. This is critical for building reliable distributed systems. In practice, I sometimes add idempotency to non-idempotent operations by accepting a client-generated idempotency key - if the same key comes in twice, I return the cached result instead of processing again."
        ],
    },
    {
        text: "What is the difference between PUT and PATCH?",
        level: Level.enum["junior-advanced"],
        category: Category.enum.backend,
        tags: [ValidTag.enum["rest-api"], ValidTag.enum["http-methods"]],
        answers: [
            "The main difference is that PUT is for full resource replacement, while PATCH is for partial updates. When you use PUT, you're expected to send the complete representation of the resource. So if you have a user object with name, email, and age, and you want to update just the email, you'd still send all three fields with PUT - the new email plus the existing name and age. If you only send the email, the other fields might get cleared or set to defaults depending on the implementation. PATCH, on the other hand, is specifically designed for partial updates. You only send the fields you want to change. So you could send just the email field, and the name and age remain untouched. Both are idempotent in theory, though PATCH can be trickier depending on how it's implemented. In practice, PUT is useful when you're updating an entire resource or when you have all the data anyway. PATCH is better when you're only changing one or two fields and don't want to require the client to send everything back.",
            "PUT replaces the entire resource, while PATCH modifies just the parts you specify. With PUT, you're saying 'here is what this resource should look like now' and you send the complete object. If you have a user with name, email, and phone, and you PUT with just email, the other fields could be nulled out. With PATCH, you send only what's changing. If I PATCH with just { email: 'new@email.com' }, only the email updates and everything else stays the same. This matters for API design. PUT is simpler conceptually - replace the whole thing. PATCH is more efficient for small updates since you're not sending unchanged data. PUT is guaranteed idempotent. PATCH should be idempotent if designed correctly, but some implementations use PATCH for operations like 'increment counter' which are not. In practice, I tend to use PATCH more often because clients usually only want to change one or two fields, and it's wasteful to make them re-send everything."
        ],
    },
    {
        text: "What are HTTP status codes and when do you use each?",
        level: Level.enum["junior-advanced"],
        category: Category.enum.backend,
        tags: [ValidTag.enum["rest-api"], ValidTag.enum["status-codes"]],
        answers: [
            "HTTP status codes are three-digit numbers that indicate the result of an HTTP request. They're grouped into five categories. The 2xx codes mean success - 200 OK is the standard success response, 201 Created is for when you've successfully created a new resource like with POST, and 204 No Content is for successful requests that don't return any data, like some DELETE operations. The 3xx codes are for redirects. The 4xx codes indicate client errors - 400 Bad Request means the request was malformed, 401 Unauthorized means authentication is required, 403 Forbidden means you're authenticated but don't have permission, 404 Not Found means the resource doesn't exist, and 422 Unprocessable Entity is for validation errors. The 5xx codes are server errors - 500 Internal Server Error is a generic server failure, and 503 Service Unavailable means the server is temporarily unable to handle requests. Using the right status codes is important because it helps clients understand what happened and how to handle the response. Like, if they get a 404, they know not to retry, but a 503 might mean they should try again later.",
            "Status codes communicate the outcome of a request at a glance. They fall into five ranges. 2xx means success: 200 for a normal successful response, 201 when you've created a new resource, 204 when the operation succeeded but there's nothing to return. 3xx handles redirects, which browsers usually follow automatically. 4xx indicates the client made a mistake: 400 means bad syntax or invalid data, 401 means you need to authenticate, 403 means you're authenticated but not authorized for this action, 404 means the resource doesn't exist, 422 is for semantic validation failures. 5xx means the server failed: 500 is a generic server error, 502 means a gateway got a bad response from an upstream server, 503 means the service is temporarily unavailable. Choosing the right code matters because it guides client behavior. A 401 tells the client to re-authenticate. A 429 tells it to slow down. A 503 with a Retry-After header tells it when to try again. Good status code usage makes your API self-documenting and easier to integrate with."
        ],
    },
    {
        text: "What are query parameters vs path parameters and when do you use each?",
        level: Level.enum["junior-advanced"],
        category: Category.enum.backend,
        tags: [ValidTag.enum["rest-api"], ValidTag.enum["api-design"]],
        answers: [
            "Path parameters are part of the URL path itself and are used to identify specific resources, while query parameters come after the question mark and are typically used for filtering, sorting, or providing optional data. For example, in /users/123, the 123 is a path parameter identifying which user. In /users?role=admin&limit=10, role and limit are query parameters filtering the results. The general rule is to use path parameters for required values that identify a resource - they're part of the resource hierarchy. So /users/:userId/posts/:postId makes sense because you're drilling down to a specific post for a specific user. Use query parameters for optional modifiers or filters that don't change which resource you're accessing, just how you're viewing it. Things like pagination, sorting, search terms, or filters. So /products?category=electronics&sort=price&page=2 is filtering and paginating the products list. Path parameters feel more permanent and structural, while query parameters feel more like adjustable settings on top of that structure.",
            "Path parameters identify which resource you're talking about. They're baked into the URL structure: /users/42/orders/7 means user 42's order number 7. They're required and define the resource hierarchy. Query parameters are optional modifiers that appear after the question mark: /orders?status=pending&limit=20. They filter, sort, or paginate without changing which resource type you're accessing. A simple rule: if removing it would mean you're looking at a different resource, it's a path parameter. If removing it just changes how you view the same resource, it's a query parameter. So /articles/5 uses a path param because article 5 is a specific resource. But /articles?author=jane&sort=date uses query params because you're still looking at articles, just filtered. Path params should be used for hierarchy: /organizations/acme/teams/engineering. Query params should be used for filtering and optional features: /teams?sort=-createdAt&page=3."
        ],
    },
];
